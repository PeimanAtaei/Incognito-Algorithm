# -*- coding: utf-8 -*-
"""incognito.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17KHxdbGmZR5bU0bn5iLpoT0utDmJyXpE
"""

import pandas as pd
import random
import queue 
import copy
IFINITI = 999999

class IDGENERATOR:
    def __init__(self):
        self.id = 0
      
    def get(self):
     result = self.id
     self.id += 1
     return result
    
    def reset(self):
      self.id = 0

IdGenerator = IDGENERATOR()

raw_data = pd.read_csv('/content/table.csv')

raw_data.head()

Q = ['year_birth', 'income', 'sex', 'zipcode', 'nationality']

"""##Value Generalization

year birth : xxxx -> xxx* -> XX**
Income : xxxxxx -> xxxxx* -> xxxx** -> XXX***
sex : M,F -> Person
Zipcode: XXXXX -> XXXX*, XXX**
Nationality : 
Italy, France, Germany, Spain,      Portugal, GreatBritian, Irland, Austria -> WestEU
Poland, Hungary, Greece -> EastEU
Danmark, Finland-> NorthEU

Year_Birth
"""

year_birth_generalization = pd.DataFrame()
year_birth_generalization['gen0'] = raw_data['year_birth']
print()
year_birth_generalization['gen1'] = year_birth_generalization.apply(lambda row: str(row['gen0'])[:-1] + "*", axis = 1)
year_birth_generalization['gen2'] = year_birth_generalization.apply(lambda row: str(row['gen0'])[:-2] + "**", axis = 1)

year_birth_generalization

"""Income

"""

income_generalization = pd.DataFrame()
income_generalization['gen0'] = raw_data['income']
income_generalization['gen1'] = income_generalization.apply(lambda row : str(row['gen0'])[:-1] + "*", axis = 1)
income_generalization['gen2'] = income_generalization.apply(lambda row : str(row['gen0'])[:-2] + "**", axis = 1)
income_generalization['gen3'] = income_generalization.apply(lambda row : str(row['gen0'])[:-3] + "***", axis = 1)

income_generalization

"""Sex"""

sex_generalization = pd.DataFrame()
sex_generalization['gen0'] = raw_data['sex']
sex_generalization['gen1'] = sex_generalization.apply(lambda row: 'person', axis=1)

sex_generalization

"""Zipcode"""

zipcode_generalization = pd.DataFrame()
zipcode_generalization['gen0'] = raw_data['zipcode']
zipcode_generalization['gen1'] = zipcode_generalization.apply(lambda row : str(row['gen0'])[:-1] + "*", axis = 1)
zipcode_generalization['gen2'] = zipcode_generalization.apply(lambda row : str(row['gen0'])[:-2] + "**", axis = 1)
zipcode_generalization['gen3'] = zipcode_generalization.apply(lambda row : str(row['gen0'])[:-3] + "***", axis = 1)

zipcode_generalization

"""Nationality : 
Italy, France, Germany, Spain,Portugal, GreatBritian, Irland, Austria -> WestEU
Poland, Hungary, Greece -> EastEU
Danmark, Finland-> NorthEU
"""

def generalizeNationality(nationality):
  west = ['Italy', 'France', 'Germany', 'Spain','Portugal', 'GreatBritian', 'Irland', 'Austria']
  east = ['Poland', 'Hungary', 'Greece']
  north = ['Danmark', 'Finland']
  if nationality in west:
    return "WestEU"
  elif nationality in east:
    return "EastEU"
  else :
    return "NorthEU"

nationality_generalization = pd.DataFrame()
nationality_generalization['gen0'] = raw_data['nationality']
nationality_generalization['gen1'] = nationality_generalization.apply(lambda row : generalizeNationality(row['gen0']), axis = 1)

nationality_generalization

generalizations = {}
generalizations['year_birth'] = year_birth_generalization
generalizations['income'] = income_generalization
generalizations['sex'] = sex_generalization
generalizations['zipcode'] = zipcode_generalization
generalizations['nationality'] = nationality_generalization

generalizations

"""Frequency-set function with pandas"""

def getFrequencySet(data, columns):
  return data.groupby(columns).size()

getFrequencySet(raw_data, ['sex', 'nationality', 'marital_status'])

def isKAnonymous(data, q, k):
  frequency = getFrequencySet(data, q)
  for fr in frequency:
    if fr < k:
      return False
  return True

isKAnonymous(raw_data, ['sex', 'nationality'], 2)

isKAnonymous(raw_data, ['sex', 'nationality', 'marital_status'], 2)

"""*Hierarchies*"""

# Q = ['Year_Birth', 'Income', 'Sex', 'Zipcode', 'Nationality']
class Node:
  def __init__(self, id):
    self.id = id
    self.year_birth = 0
    self.income = 0
    self.sex = 0
    self.zipcode = 0
    self.nationality = 0 
    self.isKAnonyminzated = False
    self.is_marked = False
    self.height = 0
    self.direct_generalizations_id = []

  def __str__(self):
    return "ID: " + str(self.id) + "\tYearBirth: " + str(self.year_birth) + "\tIncome: " + str(self.income) + "\tSex: " + str(self.sex) + "\tZipcode: " + str(self.zipcode) + "\tNationality: " + str(self.nationality) + "\tHeight: " + str(self.height)  + "\tDirect Generalizations: " + str(self.direct_generalizations_id) + "\tMarked: " + str(self.is_marked)
  
  def __lt__(self, other):
    return self.height < other.height
  
  def __eq__(self, other):
    return self.height == other.height

hierarchy = queue.PriorityQueue()

"""Dependency Tree Utils"""

def isDirectGeneralization(node1, node2, columns):
  for col in columns:
    val1 = getattr(node1, col)
    val2 = getattr(node2, col)
    if val2 == val1 or val2 == (val1 + 1):
      pass
    else:
      return False
  
  return True

def findIdOfDirectGeneralizations(node, nodes, columns):
  result = []
  for i in range(len(nodes)):
    if nodes[i].id != node.id:
      if isDirectGeneralization(node, nodes[i], columns):
        result.append(nodes[i].id)
  
  return result

def calculateHeight(node, columns):
  height = 0
  for col in columns:
    height += getattr(node, col)
  
  node.height = height
  return node

def printHierarchy(hierarchy):
  new_h = queue.PriorityQueue()
  while not hierarchy.empty():
    node = hierarchy.get()
    print(" 1- " , end=" ")
    print(node)
    new_h.put(node)
  return new_h

def recalculateHeights(nodes, columns):

  for i in range(len(nodes)):
    nodes[i] = calculateHeight(nodes[i], columns)
  return nodes

def addColumnToHierarchy(hierarchy : queue.PriorityQueue, columns, new_column, column_generalization):
  column_variaty = list(range(0,column_generalization.shape[1]))
  nodes = []
  IdGenerator.reset()
  new_hierarchy = hierarchy.empty()
  if new_hierarchy:
    for i in column_variaty:
      node = Node(IdGenerator.get())
      setattr(node, new_column, column_variaty[i])
      nodes.append(copy.copy(node))

  if not new_hierarchy:
      while not hierarchy.empty():
        node = hierarchy.get()
        first = True
        for i in column_variaty:
          setattr(node, new_column, column_variaty[i])
          node.id = IdGenerator.get()
          node.is_marked = False
          nodes.append(copy.copy(node))

  columns.append(new_column)
  nodes = recalculateHeights(nodes, columns)

  for i in range(len(nodes)):
    nodes[i].direct_generalizations_id = findIdOfDirectGeneralizations(nodes[i], nodes, columns)
    hierarchy.put(nodes[i])
  return hierarchy

nodes = []
columns = []
he = queue.PriorityQueue()
print("-------------------------------")
he = addColumnToHierarchy(he, columns, "income", generalizations["income"])
he = printHierarchy(he)

nodes = []
columns = ['zipcode', 'nationality', 'sex']

for i in range(0, 5):
  node = Node(IdGenerator.get())
  for j in columns:
    setattr(node, j, random.randint(0,4))

  
  nodes.append(node)

nodes = recalculateHeights(nodes, columns)

he = queue.PriorityQueue()
for no in nodes:
  he.put(no)

print("-------------------------------")
he = printHierarchy(he)
print("-------------------------------")
he = addColumnToHierarchy(he, columns, "income", generalizations["income"])
he = printHierarchy(he)

"""Agregate Table"""

def anonymize(data, column_generalizations, node, columns):
  result = data.copy(deep=True)
  for col in columns:
    df2 = column_generalizations[col]
    generalazation_level = 'gen' + str(getattr(node, col))
    result[col] = df2[df2['gen0'].isin(result[col])][generalazation_level].values

  return result

columns = ['zipcode', 'income', 'nationality']

node = Node(1)
node.zipcode = 3
node.nationality = 1
node.income = 3
node.year_birth = 2


re = anonymize(raw_data, generalizations, node, columns)

re

"""Mark direct generalazations"""

def markDirectGeneralizations(hierarchy, node):
  result = queue.PriorityQueue()
  while not hierarchy.empty():
    n = hierarchy.get()
    if n.id in node.direct_generalizations_id:
      n.is_marked = True
    
    result.put(n)
  
  return result


def getDirectGeneralizations(hierarchy, node, columns):
  result = []
  new_hierarchy = queue.PriorityQueue()
  while not hierarchy.empty():
    n = hierarchy.get()
    if isDirectGeneralization(node, n, columns):
      result.append(copy.copy(n))
    
    new_hierarchy.put(n)
  
  return result, hierarchy

"""Incognito: """

def Incognito(Q, generalizations, raw_data, k):
  columns = []
  hierarchy = queue.PriorityQueue()
  anonymized_nodes = []
  good_nodes = []
  for col in Q:
    found_any = False
    print("added column: " + str(col))
    for n in anonymized_nodes:
      hierarchy.put(copy.copy(n))
    print("*****************************")
    hierarchy = printHierarchy(hierarchy)
    print("*****************************")
    good_nodes = []

    hierarchy = addColumnToHierarchy(hierarchy, copy.copy(columns), col, generalizations[col])
    print("-----------------------------")
    hierarchy = printHierarchy(hierarchy)
    print("-----------------------------")
    columns.append(col)
    while not hierarchy.empty():      
      node = hierarchy.get()      
      if not node.is_marked:
        # print("2")
        anonymized = anonymize(raw_data, generalizations, node, columns)
        # print("here2")
        if isKAnonymous(anonymized, columns, k):
          print("######################################################")
          print(node)
          found_any = True
          anonymized_nodes.append(copy.copy(node))
          print("######################################################")
          node.is_marked = True
          hierarchy = markDirectGeneralizations(hierarchy, node)
          direct_generalazation, hierarchy = getDirectGeneralizations(hierarchy, node, columns)
          anonymized_nodes += direct_generalazation
        else:
          pass

    if not found_any:
      print("removed")
      columns.remove(col)
      print(columns)
  print("finished")
  return anonymized_nodes

anonymized_nodes = Incognito(Q, generalizations, raw_data, 2)

for n in anonymized_nodes:
  print(n)